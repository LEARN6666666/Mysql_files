## P85 事务Transaction  10.5
/* 
1. 事务：指代表单个工作单元的一组SQL语句。 内所有语句都应成功完成，否则事务就会运行失败。
	举例：银行交易，你想从你账户取出10美元存到你朋友账户，从你账户取出是一个操作，存入你朋友账户是一个操作，这两个操作加一起就是一个工作单元。 
          这两步哪一步操作失败，都得重来修改。
	
2. 使用情景：我们需要对数据库进行多种修改的情况下使用事务，并且希望所有更改作为一个单元一起成功或失败。
	举例：假设我们想在数据库中存储带有项目的一笔订单order_items，我们需要两段sql语句来存储这笔订单。 
          插入到orders表 和插入到order_items表，为了保持数据库一致性，我们会使用事务。 

3. 事务属性ACID：1）Atomicity原子性：事务就像原子一样，它们应牢不可破。
								 每个事物都是一个工作单元，不管包含多少语句，要么所有语句都成功执行且事务被提交；要么被退回全部更改或撤销。 
                                 
             2）Consistency一致性：意味着使用事务，数据库将始终保持一致的状态。
									不能一张表有这个数据，另一张表却没有相应记录。
                                    
			 3）Isolation 隔离性质: 意味着事务间相互隔离，或者当有同样数据被更改时各自受到保护，不会造成数据污染。 
										如果多个失误想更新相同数据，则受影响行会被锁定。
                                        因此一次只有一个事务可以更新行，其他事物必须等那个事务完成后才能进行。
			
             4）Durability 持久性：指事务一旦被提交，事务产生的更改是永久的。
									所以不用担心停电或系统崩溃，不会丢失更改内容。
*/


## P86 创建一个事务 
/* 本节课会创建一个事务来存储一笔带有item的订单order。

1. 在开始前，恢复一下数据库。（教程操作：是为了确保和MOSH老师用的一样数据 ）
	重建数据库脚本——create-databases,执行,返回查询窗口输入。
    USE sql_store;
    
    START TRANSACTION;
    
    INSERT INTO orders (custsomer_id, order_date, status) #orders表里这些列是必须的
    VALUES (1, '2019-01-01', 1);
    
    INSERT INTO order_items    #order_items表所有列都是必须的，所以不用单独列。  
    VALUES (LAST_INSERT_ID(), 1, 1, 1);     #LAST_INSERT_ID()会返回最新插入订单的ID
    
   COMMIT;  
   #COMMIT语句关闭此事务， 如果事务其中一个更改失败，它会自动撤销之前的更改。这就叫事务被退回了。    
*/

# 2. 执行以下语句，查看orders表和order_items表
/*执行代码
USE sql_store;
    
START TRANSACTION;
    
INSERT INTO orders (customer_id, order_date, status) 
VALUES (1, '2019-01-01', 1);
    
INSERT INTO order_items     
VALUES (LAST_INSERT_ID(), 1, 1, 1);     
    
COMMIT;     
*/

/* 3.试验让第二段插入语句错误，致使我们的事务被退回并且第一个语句做的更改会自动取消
	把语句放到第一段语句之前，点击上方Query,选择 Execute Current Statement, 能逐行执行脚本，右边是它的快捷键。 
    1)首先放到START那一行执行，再放到第一段INSERT那执行一次，最后直接和服务器断开连接（直接关掉sql） 
    
USE sql_store;
    
START TRANSACTION;
    
INSERT INTO orders (customer_id, order_date, status) 
VALUES (1, '2019-01-01', 1);
    
INSERT INTO order_items     
VALUES (LAST_INSERT_ID(), 1, 1, 1);     
    
COMMIT;
 */
/* 4.有些时候我们想进行一些错误检查,并手动退回了事务,这种情况,我们使用ROLLBACK语句,而不是COMMIT语句.
这样会退回事务并撤销所有更改.   

5.Mysql会装好我们写在事务里的每一条语句，然后如果语句没有返回错误，它就会提交.
  它由一个叫自动提交的系统管控，
  SHOW VARIABLES LIKE 'autocommit';
  每当我们执行一段语句，Mysql将该语句放进事务中,如果语句没有引发错误就提交.
  */
  
  
  ## P87 并发和锁定 10.11 
  /*到现在为止我们是数据库的唯一使用者，但在现实情况，会存在两个及以上的用户同时访问相同的数据的情况。 
    这种情况我们叫并发Concurrency。
    当一个用户修改其他用户正在检索或修改的数据时，并发可能会成为一个问题。
    所以我们将要学习在默认情况下，Mysql怎么处理并发问题。之后的课程会学习如何最小化并发问题。 
    
    1）首先我们要模拟两位用户同时更新指定顾客的积分的情况：
		先回到MYSQL的主页，就是左上角的小房子，新建一个服务器连接——双击Local instance mysql ,
        这样就有了两个独立的连接或会话，在我们第一个会话说，开始一个事务--给顾客一10点积分。
        打开代码后先不要执行，复制整串代码到新会话中,也暂不执行，先查看customers表一号顾客积分2273
        返回第一个会话（现在这个）逐行执行代码，使用查询窗口下的快捷键
        "Query"--"Execute Current Statement"，逐行执行到UPDATE语句，不COMMIT，去到第二个回话。 
        同行逐行执行三段代码，在UPDATE执行后，执行窗口会转圈圈，因为第一个会话更新积分后，sql会给数据加个锁， 
        如果另一个事物尝试更新同一行，他必须等到第一个事务完成（结果要么提交要么退回）。第二个超时了就在逐行执行一便 
        最后执行两个COMMIT，积分更新为2293. 
		USE sql_store;
		START TRANSACTION;
		UPDATE customers
		SET points = points + 10
		WHERE customer_id = 1;
		COMMIT;
        所以一个事务视图修改一行或者多行，它给这些行上了锁，防止其他事务修改这些行，直到第一个事务完成(被提交/退回）
        多数情况下MYSQL的默认的这种机制,你不必担心并发问题.但某些特殊情况下，默认机制不足以满足，你可以改写默认行为。
        
	*/
/*
P88 并发问题 10.19

	以下四个常见的并发问题:
    
1. 丢失更新
	当两个事务尝试更新相同的数据并没有上锁时,就会发生,在这种情况下,较晚提交的事务会覆盖较早事务做的更改,
    假设,有两个事务都试图更新同一个客户,一个想更新积分,一个想更新客户所属州,同时发生,或者前面那个运行了, 
    但没COMMIT,和下一个同时COMMIT的,那这样更新会覆盖丢失A事务更新积分的改变。
    
    用“锁”解决这个问题，上节课提到MYSQL会使用锁定机制，防止两个事务同时更新相同的数据。
    会一个事务一个事务的进行，上一个不完成，下一个不会进行。
    
2. DIRTY Reads 
	——当一个事务读取了尚未被提交的数据。
    
    举例：事务A把顾客的积分从10改成了20，但在它提交更新之前，事务B已经读取了这个客户，并且
    基于这个客户的积分数据做了某个决定，比如说每点积分基于1元的折扣，这样他应该给这名顾客20元的折扣。
    但如果事务A在事务B完成之前被退回了怎么办，——事务B就拿不到从来没存在过的数据-20分，也从未被提交过到数据库过。 
    然后事务B SELECT points语句却给了顾客20元的折扣，污染了数据。
    事务B读取了我们未提交的数据，因此我们的数据被污染了，变“脏”了。
    
    解决措施：需要为事务建立隔离级别-事务隔离级别。
    这样这项事务修改的数据不会立马被其他事物所读取，除非它提交更新了COMMIT. 
    标准的SQL定义了4个事务隔离级别，其中一个就是"READ COMMITTED"读提交，当我们对事务使用这个隔离级别时， 
那个事务只能读取已提交COMMITTED的数据.

	如果在事务完成之后数据才有修改的怎么办？
    ——不重要，因为我们在意的是我们read到的数据，至少在读取这些数据时，都是已经提交COMMITTED的数据。
后面数据也是可以变得，但是和当下的事务就没什么关系了。 

3.Non-repeating Reads 不可重复读 
	——当我们在事务中添加更多隔离时，我们可以保证事务只能读取已提交的数据，但如果你读取了某个数据两次， 
并得到了不同的结果。
	例如事务A读取了我们的客户积分10，并根据这个数据做出商业决策，在事务A完成之前，
另一个事务把这个顾客积分更新改成了0，现在回到事务A，再次读取了这个顾客积分SELECT points——0,
在事务A中我们读取了两遍同一个数据,但结果数值并不一样,这就是Non-repeating Reads问题,怎么解决? 
	坚持一点:在任何时候,我们都应根据最新信息做决定. 
在商业场景中,不必担心,在事务开始的那一刻,这个顾客有10分积分,所以我们应该给他10元折扣,如果积分在事务过程中变化 ,
我们也无法看到改变,我们能看到的只有初始快照snapshot,10积分,如果那是我们想要的,就需要增加事务隔离级别 .
我们要将它与其他事务隔离,确保数据更改对其他事务不可见,SQL定义了另一个隔离级别,叫"可重复读",在这个级别上,
我们读取的数据时可重复和一致的,就算有其他事物更改了数据,我们还是只会看到首次读取就创建的数据快照。

4.Phantom Reads 幻读
	
    比如说有一个事务A，我们要查询所有积分超过10的所有顾客，或者你想送给她们一个特别折扣码。
于此同时，事务B为另外一个顾客更新了积分，且还未被查询返回，所以这个客户其实是有资格获得这个优惠券的， 
但当我们事务A查询这张顾客表时，并没有这位客户WHERE points>10。所以当事务A完成时，仍有一个符合条件的客户没收到优惠券， 
这就是“Phantom Reads” 幻读问题。

	解决措施：取决于你想解决的商业问题具体什么样了，但你要把所有符合条件的客户都包含在我们的事务中才是至关重要的。 
要做到这点，我们必须确保没有其他事务正在运行，并会影响我们用以查找符合条件客户的事务。
为此，我们有另一个隔离级别称为"序列化”SERIALIZABLEE——它能保证当有别的事务在更新数据时，
我们的事务能够知晓变动，如果有其他事务修改可能影响查询结果的数据，我们的事务必须等它们完成， 
这样事务就会按照序列化执行，这是我们可以应用于一个事务的最高隔离级别，它为我们得操作提供了最大的确定性。 
	代价：我们拥有的用户和并发事务越多，等待时间就会越长，我们的系统也会变慢，
所以隔离级别会损害性能和可扩展性。 因为这点，我们应该只有十分有必要防止幻读时，才会使用。

*/

/*
P89 事务隔离级别 10.20

1. 有四个级别的标准事务隔离级别可以解决以上四个问题。
    第一个 READ uncommitted 基本无法解决上述任何一个问题；
    第二个 READ COMMITTED 可以解决“dirty reads“的问题；
我们只能读取已提交committed的数据，防止了脏读。但在这一级别下，事务有可能会读取两边同一个内容但得到不同结果。 
因为另外一个事务在两次读取之间更新了数据。

    第三个 REPEATEABLE READ 可以解决除“幻读”以外的其他三个问题；
	这个级别下，我们可以确保不同的读取会返回同样的结果。即使数据在此期间有所更改。

    第四个 SERILIZABLE序列化 可以解决上述所有四个问题。 
    隔离级别越高，会存在越重的性能和可扩展性问题。因为它会使用到更多隔离事务的锁。
    
    总结：更低的隔离级别会更容易引发并发，会有更多用户可以在同时接触到同一数据，
故更多的并发会产生更多的并发问题。当然，我们需要的性能也就越低，因为我们需要用以隔离的锁变少了。
较高的隔离级别限制了并发，意味着更少的并发问题，但是会以降低性能和可扩展性为代价的，
因为我们需要更多的锁和资源。故最快的隔离级别是“READ UNCOMMITTED” , 最慢的是“SERILIZABLE”.

	在mysql中，默认的事务隔离级别是"REPEATABLE READ"，比可序化块，并且防止了除幻读外大多数并发问题。 
一般情况下默认就好，除非那个事务必须用可序化执行，上面两个其他隔离性事务级别可以在要求没那么高，
或者数据不怎么更新的情况下使用。


2. 如何设置事务隔离级别
	1）首先查看当前的隔离级别 
    SHOW VARIABLES LIKE 'transaction_isolation';
    查看mysql实用的系统变量，然后LIKE筛选系统变量列表，只出现一个叫“事务隔离”的变量
	结果是'REPEATABLE-READ'-可重复读取.
    
    2）更改隔离级别 
    SET SESSION TRANSACTION ISOLATION LEVEL SERILIZABLE;
    设置SERILIZABLE隔离级别，还可以加上SESSION为当前会话或者连接以后所有的事务设定隔离级别。
    我们还可以为所有会话中的所有新事务设置全局隔离级别--SET GLOBAL TRANSACTION ISOLATION LEVEL SERILIZABLE;

	如果你是位应用开发人员,你的应用程序中某处可以连接到数据库的函数或方法,去执行某一事务,
可能是对象关系映射/直接连接到mysql。不管哪种方法，在执行事务之前，你只需要修改那个特定会话或连接的隔离级别。 
所以你连接到mysql，更改隔离级别，执行事务，然后断开连接。这样数据库中的其他事务就不会受到影响。

*/

/*
P90 读但未提交隔离级别 READ UNCOMMITTED
	1.首先关掉所有会话。
    重新打开一个会话窗口，模拟了一个客户，再返回主页打开另一个窗口，模拟第二个客户。 
    
    2.在第一个窗口，首先让我们使用sql_store.在设置事务隔离级别为"READ UNCOMMITTED"-可能会导致脏读
    USE sql_store;
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SELECT points
    FROM customers
    WHERE customer_id = 1;
    
    3.然后到另一个会话窗口，再次使用sql_store数据库，开始一个事务--更新这位客户的积分。 
    USE sql_store;
    START TRANSACTION;
    UPDATE customers
    SET points = 20
    WHERE customer_id = 1;
    COMMIT;
    
    4. 在执行这些脚本之前，让我们看看这位顾客原始积分是多少-2293分 
    
    5. 先返回到第一个会话窗口，逐行执行前两句代码，由于这里只是设置了下一个将要进行的事务隔离级别，
    并不是START TRANSACTION，现在先不执行SELECT语句。
		到第二个会话窗口，执行前三句，但不执行COMMIT提交修改。但因为我们第一个会话窗口设置的事务隔离机制 
    是READ UNCOMMITTED，所以如果逐行执行SELECT 语句会查询到更新后这位顾客的积分20，而不是2293
		更严重的是，如果第二个会话窗口由于某种原因COMMIT一直没执行，可能是服务器崩了/事务显式返回了ROLLBACK 
	那现在第一个会话窗口SELECT的就是个从未在数据库中存在的值，这就是脏读。
*/
/*
P91 READ COMMITED 读已提交隔离级别 
1. 验证脏读问题 	
	1）现在要将上面代码的隔离级别改成“读已提交”，在执行这些语句之前，再查看核对一下顾客1的积分
	再返回到第一会话窗口，执行单行SET语句	
		USE sql_store;
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
		SELECT points
		FROM customers
		WHERE customer_id = 1;

	2) 再到第二个会话窗口，再逐行执行START语句和SET语句，但没有COMMIT提交修改。
		USE sql_store;
		START TRANSACTION;
		UPDATE customers
		SET points = 20
		WHERE customer_id = 1;
		COMMIT;

	3) 再回到第一个会话读取积分——执行SELECT语句，应该还是那个未被提交修改的2293积分。

	4) 回到第二个会话，如果这个事务已经提交了，单句执行。现在再次回到第一会话执行SELECT语句 
	读取积分，结果就变成了20.所以在这一隔离级别下不存在脏读。

2.查看UNREPEATABLE READ问题
	1) 但会存在其他问题，比如 UNREPEATABLE READ，很可能在一个事务中读取同一个内容两次会有不同的结果， 
		USE sql_store;
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 
        START TRANSACTION;
		SELECT points FROM customers WHERE customer_id = 1;
		SELECT points FROM customers WHERE customer_id = 1;
		COMMIT;
     
     2) 复制好第二个SELECT语句后，再次执行第二行，来设置隔离级别。
     因为这只会对下一个事务起作用，我们已经有了一个此隔离级别的事务，所以这个新事物不会有相同的隔离级别，
     而是默认mysql隔离级别REPEATEABLE READ。
		执行完第二行后，再执行START语句，执行SELECT第一个语句，得到20.
	 
     3) 这时返回到第二个会话，修改积分30，执行所有语句包括COMMIT提交。
     返回到第一会话，执行第二句SELECT获取积分，结果30。
     所以在这一隔离级别，我们有不可重复或不一致inconsist reads,解决需要提高这个事物的隔离级别. 
*/
/*
P92 REPEATABLE READ 可重复读 隔离级别
	——这一隔离级别下的读取具有一致性和可重复性。
    只会记录第一个执行当下查询到的数据，后面数据更改后再查询也不会变。

1.验证可重复性
    1）首先提交执行上节课的代码的COMMIT；这样就可以回来更改下一个事务的隔离级别，
    将隔离级别改成REPEATABLE READ
		USE sql_store;
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 
        START TRANSACTION;
		SELECT points FROM customers WHERE customer_id = 1;
		SELECT points FROM customers WHERE customer_id = 1;
		COMMIT;
	
    2）逐行执行SET,START,SELECT第一个语句，不COMMIT；
      去到第二个会话，把积分改成40 SET points = 40; 接着执行所有语句包括COMMIT
	  再回到第一个会话，执行第二句SELECT，我们还是得到30.

2. 查看幻读问题 
	1）修改查询，来得到坐标位于Virginia的顾客， 也许你想给来自这里的顾客一个特别优惠，
		USE sql_store;
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 
        START TRANSACTION;
		SELECT * FROM customers WHERE state = 'VA';
		COMMIT;
        执行SELECT语句,会看到顾客2是唯一一个位于Virginia州的顾客.再执行COMMIT. 
	
    2)再次开始一个新事务,执行START语句,之后到第二个会话窗口,修改 SET state = 'Va'
    将顾客一的州也改成V。
		可以理解为一个人在搜索来自V的人，另一个人在更新来自V的人。
        执行第二个会话START，UPDATE语句，但是先不提交COMMIT，这还只是一个内存里的未定事务。 
      所以从技术上来讲，它还没被写入数据库，如果你返回到第一个会话，执行SELECT语句，显然只能看到顾客2.
	
    3）再返回到第二个会话，提交更改COMMIT，这样我们就有两个位于VA的顾客了，但是当你回到 
    第一会话再次执行SELECT语句时，你会发现还是只有顾客二，那是因为在可重复读 REPEATABLE READ 
    情况下，我们的读取会保持一致性。
		所以我们必须得提交第一会话的这一个事务COMMIT，再次执行SELECT语句，才可以看到两位顾客了。 
	但我们的确漏掉了一位顾客，这就是所谓的幻读。 
*/

/*
P93 SERIALIZABLE序列化隔离级别
	这一级别下，我们的事务都是按顺序依次执行的。因此可以真正完全消除并发问题。 
    
1. 验证解决幻读问题 
	1）和上一课相同例子，执行第四行SELECT语句，目前VA有两个客户。然后将事务隔离级别更改为序列化 
		USE sql_store;
		SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 
        START TRANSACTION;
		SELECT * FROM customers WHERE state = 'VA';
		COMMIT;
	执行SET,START语句
    
    2)在读取SELECT语句之前，到第二会话，再添加一个在VA的客户，WHERE customer_id = 3;
    执行START，UPDATE，并未COMMIT,所以当第一会话试图获取SELECT位于VA的顾客时，另一个会话正在更新顾客3，
    所以这个顾客应该被算进查询里，否则就是幻读了。
    先返回到第一会话执行SELECT语句，看旋转的标志，象征此事务正在等待另一个事务完成，这就是序列化格力的效果。 
    一旦我们执行第二会话COMMIT提交，事务就会执行，第一会话结果框就会出现三位位于VA的顾客。

2. 只在你想防止幻读的情况下使用这一隔离级别，而不是系统中每一个事务。
*/

/*
P94 死锁 10.22

1.死锁：就是当不同事务均因握住了别的事务需要的“锁”而无法完成的情况,所以两个事务都一直在等待对方， 
	导致永远没法解开锁.
    
    举例：关掉窗口，重新来过。在第一个会话，输入以下代码，
    更新的具体值不重要，重要的是我们现在顾客表中更新一条记录，然后需要在订单表中更新一条记录。
    USE sql_store;
	START TRANSACTION;
    UPDATE customers SET state = 'Va' WHERE customer_id = 1;
	UPDATE orders SET state = 1 WHERE order_id = 1;
	COMMIT;
    
    在执行上述代码前，复制整串代码到第二个会话中，但要调换一下两个UPDATE语句的顺序。
	再回到第一个会话，当我们执行第一个UPDATE时，会更新顾客的所在州，这个事务将锁定此记录，
所以其他事务将无法更新此条记录，它们必须得等，这与使用什么隔离级别无关。（每当我们想更新一条记录，
MYSQL会锁定该条记录，所以其他事务必须等待）。
	所以在我们执行第二个UPDATE顾客的状态时，另外一个用户（第二个会话框）同时开始了一个新事务，
这个用户要更新这张表里的一笔订单就是订单1（第一个UPDATE),所以这个客户就会锁定订单1的记录，然后， 
这行准备执行第二个UPDATE语句，更新顾客1的所在州，但是这条记录在第一个会话事务被锁定了，因此我们无法完成事务2，
必须等到事务1完成，但是当事务1要执行第二个UPDATE语句时，它被事务2锁定了，必须等到事务2完成。
	这两个事务都在等待对方，它们永远无法完成。这就是所谓的“死锁”。
    
    执行过程：先逐行执行事务1的USE,START,第一个UPDATE语句，再进入第二个会话逐行执行前四行数据，
在执行到第四行语句时，查询左上角会出现加载转圈，表示正在等待。这时返回到第一个会话，执行第四行，
现在我们陷入了死锁，查看输出窗口可以看到错误--error1213.Deadlock. 这种情况下，MYSQL将这个事务1当做受害者，
并把它退回了。

	如果你是个应用程序开发人员，你应该以这样的方式编写程序：如果事务因为死锁而被退回，可以重新恢复。
或者直接告诉用户，“这个操作失败了，你再试试。”，不过也可以做些努力最小化死锁，永远无法真正消除它，
只能减小可能性。
1）如果你经常在两个事务中检测到死锁， 查看他们的代码，这些事务可能是PROCEDURE的一部分，查看一下语句顺序， 
如果这些事务以相反的顺序更新记录，就很有可能出现死锁，所以为了减少死锁，我们在更新多条记录时，
最好遵守相同的顺序。
2）尽量简化事务，缩小事务运行时长。这样它们跟其他事务冲突的可能性就小一些，如果事务要基于非常大的表运行， 
这些事务可能需要很长时间来运行，就会有冲突的风险。这样可以试试看能不能将这些事务安排至非高峰段运行。 

*/

    
